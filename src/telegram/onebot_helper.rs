use aho_corasick::AhoCorasick;
use anyhow::Result;
use grammers_tl_types::enums::InputGeoPoint;
use grammers_tl_types::types::InputMediaVenue;
use image::GenericImageView;
use lazy_static::lazy_static;
use phf::phf_map;
use serde_json::Value;
use serde_json_path::JsonPath;
use tempfile::NamedTempFile;
use tokio::process::Command;
use webp::Encoder;

use crate::onebot::protocol::segment::Segment;

const QQ_FACE_UNKNOWN_PREFIX: &str = "/[Face";

pub fn is_sticker(segment: &Segment) -> bool {
    match segment {
        Segment::MarketFace(_) => true,
        Segment::Image(image) => match image.emoji_id {
            Some(_) => true,
            None => image
                .summary
                .as_ref()
                .is_some_and(|summary| summary.as_str() == "[åŠ¨ç”»è¡¨æƒ…]"),
        },
        _ => false,
    }
}

pub fn image_size(image_data: &[u8], mime_type: &str) -> (u32, u32) {
    if mime_type.starts_with("image") {
        image::ImageReader::new(std::io::Cursor::new(image_data))
            .with_guessed_format()
            .expect("Cursor io never fails")
            .into_dimensions()
            .unwrap_or((0, 0))
    } else {
        (0, 0)
    }
}

pub fn img_to_webp(image_data: &[u8]) -> Result<Vec<u8>> {
    let webp_data = {
        let img = image::load_from_memory(image_data)?;
        let (width, height) = img.dimensions();
        let quality = 85.0;

        let webp_data = if img.color().has_alpha() {
            let rgba = img.to_rgba8();
            Encoder::from_rgba(rgba.as_raw(), width, height)
                .encode(quality)
                .to_vec()
        } else {
            let rgb = img.to_rgb8();
            Encoder::from_rgb(rgb.as_raw(), width, height)
                .encode(quality)
                .to_vec()
        };
        webp_data
    };

    Ok(webp_data.to_vec())
}

pub async fn gif_to_webm(input_data: &[u8]) -> Result<Vec<u8>> {
    // åˆ›å»ºä¸´æ—¶æ–‡ä»¶ (é€šè¿‡ç®¡é“ä½œä¸ºè¾“å…¥åªèƒ½é¡ºåºè®¿é—®, åœ¨è½¬æ¢æ—¶å®¹æ˜“å‡ºç°é—®é¢˜)
    let temp_file = NamedTempFile::new()?;
    let input_path = temp_file
        .path()
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("Invalid temp path"))?;

    // å°†è¾“å…¥æ•°æ®å†™å…¥ä¸´æ—¶æ–‡ä»¶
    tokio::fs::write(input_path, input_data).await?;

    let child = Command::new("ffmpeg")
        .args([
            "-i",
            input_path,
            "-r",
            "30",
            "-t",
            "2.99",
            "-an",
            "-c:v",
            "libvpx-vp9",
            "-pix_fmt",
            "yuva420p",
            "-vf",
            "''scale=512:512:force_original_aspect_ratio=decrease'",
            "-b:v",
            "400K",
            "-f",
            "webm",
            "pipe:1",
        ])
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::inherit())
        .spawn()?;

    let output = child.wait_with_output().await?;
    if !output.status.success() {
        return Err(anyhow::anyhow!("ffmpeg exited: {}", output.status));
    }

    Ok(output.stdout)
}

pub async fn wav_to_ogg(input_data: &[u8]) -> Result<Vec<u8>> {
    // åˆ›å»ºä¸´æ—¶æ–‡ä»¶ (é€šè¿‡ç®¡é“ä½œä¸ºè¾“å…¥åªèƒ½é¡ºåºè®¿é—®, åœ¨è½¬æ¢æ—¶å®¹æ˜“å‡ºç°é—®é¢˜)
    let temp_file = NamedTempFile::new()?;
    let input_path = temp_file
        .path()
        .to_str()
        .ok_or_else(|| anyhow::anyhow!("Invalid temp path"))?;

    // å°†è¾“å…¥æ•°æ®å†™å…¥ä¸´æ—¶æ–‡ä»¶
    tokio::fs::write(input_path, input_data).await?;

    let child = Command::new("ffmpeg")
        .args([
            "-i", input_path, "-c:a", "libopus", "-b:a", "24K", "-f", "ogg", "pipe:1",
        ])
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::inherit())
        .spawn()?;

    let output = child.wait_with_output().await?;
    if !output.status.success() {
        return Err(anyhow::anyhow!("ffmpeg exited: {}", output.status));
    }

    Ok(output.stdout)
}

pub fn extract_location_from_json(json: &Value) -> Result<InputMediaVenue> {
    let title = JsonPath::parse("$.meta.*.name")?
        .query(json)
        .exactly_one()
        .map(|v| v.as_str().unwrap())?
        .to_string();
    let address = JsonPath::parse("$.meta.*.address")?
        .query(json)
        .exactly_one()
        .map(|v| v.as_str().unwrap())?
        .to_string();
    let lat = JsonPath::parse("$.meta.*.lat")?
        .query(json)
        .exactly_one()
        .map(|v| v.as_str().unwrap().parse::<f64>().unwrap())?;
    let long = JsonPath::parse("$.meta.*.lng")?
        .query(json)
        .exactly_one()
        .map(|v| v.as_str().unwrap().parse::<f64>().unwrap())?;

    Ok(InputMediaVenue {
        geo_point: InputGeoPoint::Point(grammers_tl_types::types::InputGeoPoint {
            lat,
            long,
            accuracy_radius: None,
        }),
        title,
        address,
        provider: String::new(),
        venue_id: String::new(),
        venue_type: String::new(),
    })
}

pub fn extract_share_from_json(json: &Value) -> Result<String> {
    let (title, description, source, url);

    let doc_node = JsonPath::parse("$.meta.*.qqdocurl")?.query(json);
    if doc_node.is_empty() {
        let jump_node = JsonPath::parse("$.meta.*.jumpUrl")?.query(json);
        if jump_node.is_empty() {
            return Ok(String::new());
        } else {
            url = jump_node.exactly_one().map(|v| v.as_str().unwrap())?;
            source = JsonPath::parse("$.meta.*.tag")?
                .query(json)
                .exactly_one()
                .map(|v| v.as_str().unwrap())?;
            description = JsonPath::parse("$.meta.*.desc")?
                .query(json)
                .exactly_one()
                .map(|v| v.as_str().unwrap())?;
            title = JsonPath::parse("$.prompt")?
                .query(json)
                .exactly_one()
                .map(|v| v.as_str().unwrap())?;
        }
    } else {
        url = doc_node.exactly_one().map(|v| v.as_str().unwrap())?;
        source = JsonPath::parse("$.meta.*.title")?
            .query(json)
            .exactly_one()
            .map(|v| v.as_str().unwrap())?;
        description = JsonPath::parse("$.meta.*.desc")?
            .query(json)
            .exactly_one()
            .map(|v| v.as_str().unwrap())?;
        title = JsonPath::parse("$.prompt")?
            .query(json)
            .exactly_one()
            .map(|v| v.as_str().unwrap())?;
    }

    Ok(format!(
        "<u>{}</u>\n\n{}\n\nvia <a href=\"{}\">{}</a>",
        html_escape::encode_text(title),
        html_escape::encode_text(description),
        html_escape::encode_text(url),
        html_escape::encode_text(source),
    ))
}

static QQ_EMOJI: phf::Map<&'static str, &'static str> = phf_map! {
    "0" => "/æƒŠè®¶",
    "1" => "/æ’‡å˜´",
    "2" => "/è‰²",
    "3" => "/å‘å‘†",
    "4" => "/å¾—æ„",
    "5" => "/æµæ³ª",
    "6" => "/å®³ç¾",
    "7" => "/é—­å˜´",
    "8" => "/ç¡",
    "9" => "/å¤§å“­",
    "10" => "/å°´å°¬",
    "11" => "/å‘æ€’",
    "12" => "/è°ƒçš®",
    "13" => "/å‘²ç‰™",
    "14" => "/å¾®ç¬‘",
    "15" => "/éš¾è¿‡",
    "16" => "/é…·",
    "18" => "/æŠ“ç‹‚",
    "19" => "/å",
    "20" => "/å·ç¬‘",
    "21" => "/å¯çˆ±",
    "22" => "/ç™½çœ¼",
    "23" => "/å‚²æ…¢",
    "24" => "/é¥¥é¥¿",
    "25" => "/å›°",
    "26" => "/æƒŠæ",
    "27" => "/æµæ±—",
    "28" => "/æ†¨ç¬‘",
    "29" => "/æ‚ é—²",
    "30" => "/å¥‹æ–—",
    "31" => "/å’’éª‚",
    "32" => "/ç–‘é—®",
    "33" => "/å˜˜",
    "34" => "/æ™•",
    "35" => "/æŠ˜ç£¨",
    "36" => "/è¡°",
    "37" => "/éª·é«…",
    "38" => "/æ•²æ‰“",
    "39" => "/å†è§",
    "41" => "/å‘æŠ–",
    "42" => "/çˆ±æƒ…",
    "43" => "/è·³è·³",
    "46" => "/çŒªå¤´",
    "49" => "/æ‹¥æŠ±",
    "53" => "/è›‹ç³•",
    "54" => "/é—ªç”µ",
    "55" => "/ç‚¸å¼¹",
    "56" => "/åˆ€",
    "57" => "/è¶³çƒ",
    "59" => "/ä¾¿ä¾¿",
    "60" => "/å’–å•¡",
    "61" => "/é¥­",
    "63" => "/ç«ç‘°",
    "64" => "/å‡‹è°¢",
    "66" => "/çˆ±å¿ƒ",
    "67" => "/å¿ƒç¢",
    "69" => "/ç¤¼ç‰©",
    "74" => "/å¤ªé˜³",
    "75" => "/æœˆäº®",
    "76" => "/èµ",
    "77" => "/è¸©",
    "78" => "/æ¡æ‰‹",
    "79" => "/èƒœåˆ©",
    "85" => "/é£å»",
    "86" => "/æ€„ç«",
    "89" => "/è¥¿ç“œ",
    "96" => "/å†·æ±—",
    "97" => "/æ“¦æ±—",
    "98" => "/æŠ é¼»",
    "99" => "/é¼“æŒ",
    "100" => "/ç³—å¤§äº†",
    "101" => "/åç¬‘",
    "102" => "/å·¦å“¼å“¼",
    "103" => "/å³å“¼å“¼",
    "104" => "/å“ˆæ¬ ",
    "105" => "/é„™è§†",
    "106" => "/å§”å±ˆ",
    "107" => "/å¿«å“­äº†",
    "108" => "/é˜´é™©",
    "109" => "/å·¦äº²äº²",
    "110" => "/å“",
    "111" => "/å¯æ€œ",
    "112" => "/èœåˆ€",
    "113" => "/å•¤é…’",
    "114" => "/ç¯®çƒ",
    "115" => "/ä¹’ä¹“",
    "116" => "/ç¤ºçˆ±",
    "117" => "/ç“¢è™«",
    "118" => "/æŠ±æ‹³",
    "119" => "/å‹¾å¼•",
    "120" => "/æ‹³å¤´",
    "121" => "/å·®åŠ²",
    "122" => "/çˆ±ä½ ",
    "123" => "/NO",
    "124" => "/OK",
    "125" => "/è½¬åœˆ",
    "126" => "/ç£•å¤´",
    "127" => "/å›å¤´",
    "128" => "/è·³ç»³",
    "129" => "/æŒ¥æ‰‹",
    "130" => "/æ¿€åŠ¨",
    "131" => "/è¡—èˆ",
    "132" => "/çŒ®å»",
    "133" => "/å·¦å¤ªæ",
    "134" => "/å³å¤ªæ",
    "136" => "/åŒå–œ",
    "137" => "/é­ç‚®",
    "138" => "/ç¯ç¬¼",
    "140" => "/Kæ­Œ",
    "144" => "/å–å½©",
    "145" => "/ç¥ˆç¥·",
    "146" => "/çˆ†ç­‹",
    "147" => "/æ£’æ£’ç³–",
    "148" => "/å–å¥¶",
    "151" => "/é£æœº",
    "158" => "/é’ç¥¨",
    "168" => "/è¯",
    "169" => "/æ‰‹æª",
    "171" => "/èŒ¶",
    "172" => "/çœ¨çœ¼ç›",
    "173" => "/æ³ªå¥”",
    "174" => "/æ— å¥ˆ",
    "175" => "/å–èŒ",
    "176" => "/å°çº ç»“",
    "177" => "/å–·è¡€",
    "178" => "/æ–œçœ¼ç¬‘",
    "179" => "/doge",
    "180" => "/æƒŠå–œ",
    "181" => "/éªšæ‰°",
    "182" => "/ç¬‘å“­",
    "183" => "/æˆ‘æœ€ç¾",
    "184" => "/æ²³èŸ¹",
    "185" => "/ç¾Šé©¼",
    "187" => "/å¹½çµ",
    "188" => "/è›‹",
    "190" => "/èŠèŠ±",
    "192" => "/çº¢åŒ…",
    "193" => "/å¤§ç¬‘",
    "194" => "/ä¸å¼€å¿ƒ",
    "197" => "/å†·æ¼ ",
    "198" => "/å‘ƒ",
    "199" => "/å¥½æ£’",
    "200" => "/æ‹œæ‰˜",
    "201" => "/ç‚¹èµ",
    "202" => "/æ— èŠ",
    "203" => "/æ‰˜è„¸",
    "204" => "/åƒ",
    "205" => "/é€èŠ±",
    "206" => "/å®³æ€•",
    "207" => "/èŠ±ç—´",
    "208" => "/å°æ ·å„¿",
    "210" => "/é£™æ³ª",
    "211" => "/æˆ‘ä¸çœ‹",
    "212" => "/æ‰˜è…®",
    "214" => "/å•µå•µ",
    "215" => "/ç³Šè„¸",
    "216" => "/æ‹å¤´",
    "217" => "/æ‰¯ä¸€æ‰¯",
    "218" => "/èˆ”ä¸€èˆ”",
    "219" => "/è¹­ä¸€è¹­",
    "220" => "/æ‹½ç‚¸å¤©",
    "221" => "/é¡¶å‘±å‘±",
    "222" => "/æŠ±æŠ±",
    "223" => "/æš´å‡»",
    "224" => "/å¼€æª",
    "225" => "/æ’©ä¸€æ’©",
    "226" => "/æ‹æ¡Œ",
    "227" => "/æ‹æ‰‹",
    "228" => "/æ­å–œ",
    "229" => "/å¹²æ¯",
    "230" => "/å˜²è®½",
    "231" => "/å“¼",
    "232" => "/ä½›ç³»",
    "233" => "/æä¸€æ",
    "234" => "/æƒŠå‘†",
    "235" => "/é¢¤æŠ–",
    "236" => "/å•ƒå¤´",
    "237" => "/å·çœ‹",
    "238" => "/æ‰‡è„¸",
    "239" => "/åŸè°…",
    "240" => "/å–·è„¸",
    "241" => "/ç”Ÿæ—¥å¿«ä¹",
    "242" => "/å¤´æ’å‡»",
    "243" => "/ç”©å¤´",
    "244" => "/æ‰”ç‹—",
    "245" => "/åŠ æ²¹å¿…èƒœ",
    "246" => "/åŠ æ²¹æŠ±æŠ±",
    "247" => "/å£ç½©æŠ¤ä½“",
    "260" => "/æ¬ç –ä¸­",
    "261" => "/å¿™åˆ°é£èµ·",
    "262" => "/è„‘é˜”ç–¼",
    "263" => "/æ²§æ¡‘",
    "264" => "/æ‚è„¸",
    "265" => "/è¾£çœ¼ç›",
    "266" => "/å“¦å“Ÿ",
    "267" => "/å¤´ç§ƒ",
    "268" => "/é—®å·è„¸",
    "269" => "/æš—ä¸­è§‚å¯Ÿ",
    "270" => "/emm",
    "271" => "/åƒç“œ",
    "272" => "/å‘µå‘µå“’",
    "273" => "/æˆ‘é…¸äº†",
    "274" => "/å¤ªå—äº†",
    "276" => "/è¾£æ¤’é…±",
    "277" => "/æ±ªæ±ª",
    "278" => "/æ±—",
    "279" => "/æ‰“è„¸",
    "280" => "/å‡»æŒ",
    "281" => "/æ— çœ¼ç¬‘",
    "282" => "/æ•¬ç¤¼",
    "283" => "/ç‹‚ç¬‘",
    "284" => "/é¢æ— è¡¨æƒ…",
    "285" => "/æ‘¸é±¼",
    "286" => "/é­”é¬¼ç¬‘",
    "287" => "/å“¦",
    "288" => "/è¯·",
    "289" => "/ççœ¼",
    "290" => "/æ•²å¼€å¿ƒ",
    "291" => "/éœ‡æƒŠ",
    "292" => "/è®©æˆ‘åº·åº·",
    "293" => "/æ‘¸é”¦é²¤",
    "294" => "/æœŸå¾…",
    "295" => "/æ‹¿åˆ°çº¢åŒ…",
    "296" => "/çœŸå¥½",
    "297" => "/æ‹œè°¢",
    "298" => "/å…ƒå®",
    "299" => "/ç‰›å•Š",
    "300" => "/èƒ–ä¸‰æ–¤",
    "301" => "/å¥½é—ª",
    "302" => "/å·¦æ‹œå¹´",
    "303" => "/å³æ‹œå¹´",
    "304" => "/çº¢åŒ…åŒ…",
    "305" => "/å³äº²äº²",
    "306" => "/ç‰›æ°”å†²å¤©",
    "307" => "/å–µå–µ",
    "308" => "/æ±‚çº¢åŒ…",
    "309" => "/è°¢çº¢åŒ…",
    "310" => "/æ–°å¹´çƒŸèŠ±",
    "311" => "/æ‰“call",
    "312" => "/å˜å½¢",
    "313" => "/å—‘åˆ°äº†",
    "314" => "/ä»”ç»†åˆ†æ",
    "315" => "/åŠ æ²¹",
    "316" => "/æˆ‘æ²¡äº‹",
    "317" => "/èœæ±ª",
    "318" => "/å´‡æ‹œ",
    "319" => "/æ¯”å¿ƒ",
    "320" => "/åº†ç¥",
    "321" => "/è€è‰²ç—",
    "322" => "/æ‹’ç»",
    "323" => "/å«Œå¼ƒ",
    "324" => "/åƒç³–",
    "325" => "/æƒŠå“",
    "326" => "/ç”Ÿæ°”",
    "327" => "/åŠ ä¸€",
    "328" => "/é”™å·",
    "329" => "/å¯¹å·",
    "330" => "/å®Œæˆ",
    "331" => "/æ˜ç™½",
    "332" => "/ä¸¾ç‰Œç‰Œ",
    "333" => "/çƒŸèŠ±",
    "334" => "/è™è™ç”Ÿå¨",
    "336" => "/è±¹å¯Œ",
    "337" => "/èŠ±æœµè„¸",
    "338" => "/æˆ‘æƒ³å¼€äº†",
    "339" => "/èˆ”å±",
    "340" => "/çƒ­åŒ–äº†",
    "341" => "/æ‰“æ‹›å‘¼",
    "342" => "/é…¸Q",
    "343" => "/æˆ‘æ–¹äº†",
    "344" => "/å¤§æ€¨ç§",
    "345" => "/çº¢åŒ…å¤šå¤š",
    "346" => "/ä½ çœŸæ£’æ£’",
    "347" => "/å¤§å±•å®å…”",
    "348" => "/ç¦èåœ",
};

const WECHAT_EMOJI_REPLACEMENTS: &[(&str, &str)] = &[
    ("[å¾®ç¬‘]", "ğŸ˜ƒ"),
    ("[Smile]", "ğŸ˜ƒ"),
    ("[è‰²]", "ğŸ˜"),
    ("[Drool]", "ğŸ˜"),
    ("[å‘å‘†]", "ğŸ˜³"),
    ("[Scowl]", "ğŸ˜³"),
    ("[å¾—æ„]", "ğŸ˜"),
    ("[Chill]", "ğŸ˜"),
    ("[æµæ³ª]", "ğŸ˜­"),
    ("[Sob]", "ğŸ˜­"),
    ("[å®³ç¾]", "â˜ºï¸"),
    ("[Shy]", "â˜ºï¸"),
    ("[é—­å˜´]", "ğŸ¤"),
    ("[Shutup]", "ğŸ¤"),
    ("[ç¡]", "ğŸ˜´"),
    ("[Sleep]", "ğŸ˜´"),
    ("[å¤§å“­]", "ğŸ˜£"),
    ("[Cry]", "ğŸ˜£"),
    ("[å°´å°¬]", "ğŸ˜°"),
    ("[Awkward]", "ğŸ˜°"),
    ("[å‘æ€’]", "ğŸ˜¡"),
    ("[Pout]", "ğŸ˜¡"),
    ("[è°ƒçš®]", "ğŸ˜œ"),
    ("[Wink]", "ğŸ˜œ"),
    ("[å‘²ç‰™]", "ğŸ˜"),
    ("[Grin]", "ğŸ˜"),
    ("[æƒŠè®¶]", "ğŸ˜±"),
    ("[Surprised]", "ğŸ˜±"),
    ("[éš¾è¿‡]", "ğŸ™"),
    ("[Frown]", "ğŸ™"),
    ("[å›§]", "â˜ºï¸"),
    ("[Tension]", "â˜ºï¸"),
    ("[æŠ“ç‹‚]", "ğŸ˜«"),
    ("[Scream]", "ğŸ˜«"),
    ("[å]", "ğŸ¤¢"),
    ("[Puke]", "ğŸ¤¢"),
    ("[å·ç¬‘]", "ğŸ™ˆ"),
    ("[Chuckle]", "ğŸ™ˆ"),
    ("[æ„‰å¿«]", "â˜ºï¸"),
    ("[Joyful]", "â˜ºï¸"),
    ("[ç™½çœ¼]", "ğŸ™„"),
    ("[Slight]", "ğŸ™„"),
    ("[å‚²æ…¢]", "ğŸ˜•"),
    ("[Smug]", "ğŸ˜•"),
    ("[å›°]", "ğŸ˜ª"),
    ("[Drowsy]", "ğŸ˜ª"),
    ("[æƒŠæ]", "ğŸ˜±"),
    ("[Panic]", "ğŸ˜±"),
    ("[æµæ±—]", "ğŸ˜“"),
    ("[Sweat]", "ğŸ˜“"),
    ("[æ†¨ç¬‘]", "ğŸ˜„"),
    ("[Laugh]", "ğŸ˜„"),
    ("[æ‚ é—²]", "ğŸ˜"),
    ("[Loafer]", "ğŸ˜"),
    ("[å¥‹æ–—]", "ğŸ’ª"),
    ("[Strive]", "ğŸ’ª"),
    ("[å’’éª‚]", "ğŸ˜¤"),
    ("[Scold]", "ğŸ˜¤"),
    ("[ç–‘é—®]", "â“"),
    ("[Doubt]", "â“"),
    ("[å˜˜]", "ğŸ¤"),
    ("[Shhh]", "ğŸ¤"),
    ("[æ™•]", "ğŸ˜²"),
    ("[Dizzy]", "ğŸ˜²"),
    ("[è¡°]", "ğŸ˜³"),
    ("[BadLuck]", "ğŸ˜³"),
    ("[éª·é«…]", "ğŸ’€"),
    ("[Skull]", "ğŸ’€"),
    ("[æ•²æ‰“]", "ğŸ‘Š"),
    ("[Hammer]", "ğŸ‘Š"),
    ("[å†è§]", "ğŸ™‹â™‚"),
    ("[Bye]", "ğŸ™‹â™‚"),
    ("[æ“¦æ±—]", "ğŸ˜¥"),
    ("[Relief]", "ğŸ˜¥"),
    ("[æŠ é¼»]", "ğŸ¤·â™‚"),
    ("[DigNose]", "ğŸ¤·â™‚"),
    ("[é¼“æŒ]", "ğŸ‘"),
    ("[Clap]", "ğŸ‘"),
    ("[åç¬‘]", "ğŸ‘»"),
    ("[Trick]", "ğŸ‘»"),
    ("[å·¦å“¼å“¼]", "ğŸ˜¾"),
    ("[Bahï¼L]", "ğŸ˜¾"),
    ("[å³å“¼å“¼]", "ğŸ˜¾"),
    ("[Bahï¼R]", "ğŸ˜¾"),
    ("[å“ˆæ¬ ]", "ğŸ˜ª"),
    ("[Yawn]", "ğŸ˜ª"),
    ("[é„™è§†]", "ğŸ˜’"),
    ("[Lookdown]", "ğŸ˜’"),
    ("[å§”å±ˆ]", "ğŸ˜£"),
    ("[Wronged]", "ğŸ˜£"),
    ("[å¿«å“­äº†]", "ğŸ˜”"),
    ("[Puling]", "ğŸ˜”"),
    ("[é˜´é™©]", "ğŸ˜ˆ"),
    ("[Sly]", "ğŸ˜ˆ"),
    ("[äº²äº²]", "ğŸ˜˜"),
    ("[Kiss]", "ğŸ˜˜"),
    ("[å¯æ€œ]", "ğŸ˜»"),
    ("[Whimper]", "ğŸ˜»"),
    ("[èœåˆ€]", "ğŸ”ª"),
    ("[Cleaver]", "ğŸ”ª"),
    ("[è¥¿ç“œ]", "ğŸ‰"),
    ("[Melon]", "ğŸ‰"),
    ("[å•¤é…’]", "ğŸº"),
    ("[Beer]", "ğŸº"),
    ("[å’–å•¡]", "â˜•"),
    ("[Coffee]", "â˜•"),
    ("[çŒªå¤´]", "ğŸ·"),
    ("[Pig]", "ğŸ·"),
    ("[ç«ç‘°]", "ğŸŒ¹"),
    ("[Rose]", "ğŸŒ¹"),
    ("[å‡‹è°¢]", "ğŸ¥€"),
    ("[Wilt]", "ğŸ¥€"),
    ("[å˜´å”‡]", "ğŸ’‹"),
    ("[Lip]", "ğŸ’‹"),
    ("[çˆ±å¿ƒ]", "â¤ï¸"),
    ("[Heart]", "â¤ï¸"),
    ("[å¿ƒç¢]", "ğŸ’”"),
    ("[BrokenHeart]", "ğŸ’”"),
    ("[è›‹ç³•]", "ğŸ‚"),
    ("[Cake]", "ğŸ‚"),
    ("[ç‚¸å¼¹]", "ğŸ’£"),
    ("[Bomb]", "ğŸ’£"),
    ("[ä¾¿ä¾¿]", "ğŸ’©"),
    ("[Poop]", "ğŸ’©"),
    ("[æœˆäº®]", "ğŸŒƒ"),
    ("[Moon]", "ğŸŒƒ"),
    ("[å¤ªé˜³]", "ğŸŒ"),
    ("[Sun]", "ğŸŒ"),
    ("[æ‹¥æŠ±]", "ğŸ¤—"),
    ("[Hug]", "ğŸ¤—"),
    ("[å¼º]", "ğŸ‘"),
    ("[Strong]", "ğŸ‘"),
    ("[å¼±]", "ğŸ‘"),
    ("[Weak]", "ğŸ‘"),
    ("[æ¡æ‰‹]", "ğŸ¤"),
    ("[Shake]", "ğŸ¤"),
    ("[èƒœåˆ©]", "âœŒï¸"),
    ("[Victory]", "âœŒï¸"),
    ("[æŠ±æ‹³]", "ğŸ™"),
    ("[Salute]", "ğŸ™"),
    ("[å‹¾å¼•]", "ğŸ’â™‚"),
    ("[Beckon]", "ğŸ’â™‚"),
    ("[æ‹³å¤´]", "ğŸ‘Š"),
    ("[Fist]", "ğŸ‘Š"),
    ("[OK]", "ğŸ‘Œ"),
    ("[è·³è·³]", "ğŸ’ƒ"),
    ("[Waddle]", "ğŸ’ƒ"),
    ("[å‘æŠ–]", "ğŸ™‡"),
    ("[Tremble]", "ğŸ™‡"),
    ("[æ€„ç«]", "ğŸ˜¡"),
    ("[Aaagh!]", "ğŸ˜¡"),
    ("[è½¬åœˆ]", "ğŸ•º"),
    ("[Twirl]", "ğŸ•º"),
    ("[å˜¿å“ˆ]", "ğŸ¤£"),
    ("[Hey]", "ğŸ¤£"),
    ("[æ‚è„¸]", "ğŸ¤¦â™‚"),
    ("[Facepalm]", "ğŸ¤¦â™‚"),
    ("[å¥¸ç¬‘]", "ğŸ˜œ"),
    ("[Smirk]", "ğŸ˜œ"),
    ("[æœºæ™º]", "ğŸ¤“"),
    ("[Smart]", "ğŸ¤“"),
    ("[çš±çœ‰]", "ğŸ˜Ÿ"),
    ("[Concerned]", "ğŸ˜Ÿ"),
    ("[è€¶]", "âœŒï¸"),
    ("[Yeah!]", "âœŒï¸"),
    ("[çº¢åŒ…]", "ğŸ§§"),
    ("[Packet]", "ğŸ§§"),
    ("[é¸¡]", "ğŸ¥"),
    ("[Chick]", "ğŸ¥"),
    ("[èœ¡çƒ›]", "ğŸ•¯ï¸"),
    ("[Candle]", "ğŸ•¯ï¸"),
    ("[ç³—å¤§äº†]", "ğŸ˜¥"),
    ("[ThumbsUp]", "ğŸ‘"),
    ("[ThumbsDown]", "ğŸ‘"),
    ("[Peace]", "âœŒï¸"),
    ("[Pleased]", "ğŸ˜Š"),
    ("[Rich]", "ğŸ€…"),
    ("[Pup]", "ğŸ¶"),
    ("[åƒç“œ]", "ğŸ™„ğŸ‰"),
    ("[Onlooker]", "ğŸ™„ğŸ‰"),
    ("[åŠ æ²¹]", "ğŸ’ªğŸ˜"),
    ("[GoForIt]", "ğŸ’ªğŸ˜"),
    ("[åŠ æ²¹åŠ æ²¹]", "ğŸ’ªğŸ˜·"),
    ("[æ±—]", "ğŸ˜“"),
    ("[Sweats]", "ğŸ˜“"),
    ("[å¤©å•Š]", "ğŸ˜±"),
    ("[OMG]", "ğŸ˜±"),
    ("[Emm]", "ğŸ¤”"),
    ("[ç¤¾ä¼šç¤¾ä¼š]", "ğŸ˜"),
    ("[Respect]", "ğŸ˜"),
    ("[æ—ºæŸ´]", "ğŸ¶ğŸ˜"),
    ("[Doge]", "ğŸ¶ğŸ˜"),
    ("[å¥½çš„]", "ğŸ˜ğŸ‘Œ"),
    ("[NoProb]", "ğŸ˜ğŸ‘Œ"),
    ("[å“‡]", "ğŸ¤©"),
    ("[Wow]", "ğŸ¤©"),
    ("[æ‰“è„¸]", "ğŸ˜ŸğŸ¤š"),
    ("[MyBad]", "ğŸ˜ŸğŸ¤š"),
    ("[ç ´æ¶•ä¸ºç¬‘]", "ğŸ˜‚"),
    ("[ç ´æ¶•ç‚ºç¬‘]", "ğŸ˜‚"),
    ("[Lol]", "ğŸ˜‚"),
    ("[è‹¦æ¶©]", "ğŸ˜­"),
    ("[Hurt]", "ğŸ˜­"),
    ("[ç¿»ç™½çœ¼]", "ğŸ™„"),
    ("[Boring]", "ğŸ™„"),
    ("[è£‚å¼€]", "ğŸ« "),
    ("[Broken]", "ğŸ« "),
    ("[çˆ†ç«¹]", "ğŸ§¨"),
    ("[Firecracker]", "ğŸ§¨"),
    ("[çƒŸèŠ±]", "ğŸ†"),
    ("[Fireworks]", "ğŸ†"),
    ("[ç¦]", "ğŸ§§"),
    ("[Blessing]", "ğŸ§§"),
    ("[ç¤¼ç‰©]", "ğŸ"),
    ("[Gift]", "ğŸ"),
    ("[åº†ç¥]", "ğŸ‰"),
    ("[Party]", "ğŸ‰"),
    ("[åˆå]", "ğŸ™"),
    ("[Worship]", "ğŸ™"),
    ("[å¹æ°”]", "ğŸ˜®ğŸ’¨"),
    ("[Sigh]", "ğŸ˜®ğŸ’¨"),
    ("[è®©æˆ‘çœ‹çœ‹]", "ğŸ‘€"),
    ("[LetMeSee]", "ğŸ‘€"),
    ("[666]", "6ï¸âƒ£6ï¸âƒ£6ï¸âƒ£"),
    ("[æ— è¯­]", "ğŸ˜‘"),
    ("[Duh]", "ğŸ˜‘"),
    ("[å¤±æœ›]", "ğŸ˜"),
    ("[Let Down]", "ğŸ˜"),
    ("[ææƒ§]", "ğŸ˜¨"),
    ("[Terror]", "ğŸ˜¨"),
    ("[è„¸çº¢]", "ğŸ˜³"),
    ("[Flushed]", "ğŸ˜³"),
    ("[ç”Ÿç—…]", "ğŸ˜·"),
    ("[Sick]", "ğŸ˜·"),
    ("[ç¬‘è„¸]", "ğŸ˜"),
    ("[Happy]", "ğŸ˜"),
];

lazy_static! {
    static ref EMOJI_REPLACER: AhoCorasick = {
        let patterns: Vec<&str> = WECHAT_EMOJI_REPLACEMENTS
            .iter()
            .map(|(old, _)| *old)
            .collect();
        AhoCorasick::new(patterns).unwrap()
    };
    static ref EMOJI_REPLACEMENTS: Vec<&'static str> = {
        WECHAT_EMOJI_REPLACEMENTS
            .iter()
            .map(|(_, new)| *new)
            .collect()
    };
}

pub fn replace_qq_face(id: &str) -> String {
    if let Some(face) = QQ_EMOJI.get(id) {
        face.to_string()
    } else {
        let mut result = String::with_capacity(QQ_FACE_UNKNOWN_PREFIX.len() + id.len() + 1);
        result.push_str(QQ_FACE_UNKNOWN_PREFIX);
        result.push_str(id);
        result.push(']');
        result
    }
}

pub fn replace_wechat_emoji(content: &str) -> String {
    EMOJI_REPLACER.replace_all(content, &EMOJI_REPLACEMENTS)
}
